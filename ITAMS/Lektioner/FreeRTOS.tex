\section{Lektion 01-03-2018}
\subsection{FreeRTOS}

Understanding and “Hands On” the FreeRTOS real time operating system.
\subsubsection{Exercise, Part 1}

\subsubsection{Exercise, Part 2}
\begin{itemize}
	\item The first (extra) task shall wait for switch SW0 to be pressed.
	When this is the case, the semaphore shall be given.
	Use the switch port driver to read the switch.
	\item The second task shall wait for the semaphore (take it).
	When taken, LED7 shall flash (on for a few milliseconds).
	Use the LED driver to control LED7.
\end{itemize}

\begin{minted}{c}
xSemaphoreHandle xSemaphore1 = NULL;

void vSwitchTask( void * pvParameters )
{
xSemaphoreTake( xSemaphore1, portMAX_DELAY );
    while(1)
    {
    /* We now have the semaphore and can wait for SW0 to
    give the semaphore. */
    if (switchOn(0))
        xSemaphoreGive(xSemaphore1);
    }
}

void vLEDFlashTask3( void * pvParameters )
{
    /* If the semaphore is not available wait to see if it
    becomes free. */
    if( xSemaphoreTake( xSemaphore1, portMAX_DELAY ))
    {
        /* We were able to obtain the semaphore. */
        turnOnLED(7);
        vTaskDelay(500);
        turnOffLED(7);

        /* Release the semaphore. */
        xSemaphoreGive( xSemaphore1 );
    }
}

int main(void)
{
    initLEDport();
    initSwitchPort();

    /* Create the semaphore to guard a shared resource. */
    vSemaphoreCreateBinary(xSemaphore1);

    xTaskCreate( vSwitchTask,    ( signed char * ) "SW0", ...
    configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
    xTaskCreate( vLEDFlashTask3, ( signed char * ) "LED7", ...
    configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );	
    vTaskStartScheduler();
    while(1)
    {}
}
\end{minted}

\subsubsection{Exercise, Part 3}
Write a program having 3 tasks.\\

\noindent Also the program has a global variable called "count" (type unsigned char), being a common resource for two of the tasks. Therefore this variable has to be protected using a (binary) semaphore!\\

\noindent A queue for 10 bytes is used for data transfer between the tasks.
\begin{itemize}
	\item The first task shall decrement "count" when switch SW0 is pressed.
	Then the value of "count" shall be put onto the queue.
	\item The second task shall increment “count” when SW1 is pressed.
	Then the value of "count" shall be put onto the queue.
	\item The third task must receive items from the queue.
	Each time a new item is received, the value of the element shall be displayed at the LEDs (use
	the LED driver). Also the same value shall be sent as a text string to an attached terminal (use
	the UART driver function SendInteger() ).
	\item Use an interrupt (for example external INT0 edge-triggered) to reset "count" to 0.
	Also the value 0 shall be put onto the queue.
	Remember to use special FreeRTOS functions when called form an ISR
\end{itemize}

\begin{minted}{c}
unsigned char count = 0;
xSemaphoreHandle xSemaphore1 = NULL;
xQueueHandle xQueue1 = NULL;

void initExtInts()
{
    /* INT2:Falling edge. */
    EICRA = 0b00100000;
    /* Enable extern interrupt INT2. */
    EIMSK |= 0b00001000;
}

ISR (INT2_vect)
{
    if( xSemaphoreTake( xSemaphore1, 0 ) == pdTRUE )
    {
        count = 0;
        /* Don't block if the queue is already full. */
        xQueueSendToBackFromISR( xQueue1, &count, 0 );
        xSemaphoreGiveFromISR( xSemaphore1, NULL );
    }
}
\end{minted}
\newpage
\begin{minted}{c}
void vDecCountTask( void * pvParameters )
{
    while(1)
    {
        if (switchOn(0))
        {
            xSemaphoreTake( xSemaphore1, portMAX_DELAY );
            count--;
            /* Don't block if the queue is already full. */
            xQueueSendToBack( xQueue1, &count, 0 );
            xSemaphoreGive( xSemaphore1 );
        }
        vTaskDelay(50);
    }
}

void vIncCountTask( void * pvParameters )
{
    while(1)
    {
        if (switchOn(1))
        {
            xSemaphoreTake( xSemaphore1, portMAX_DELAY );
            count++;
            /* Don't block if the queue is already full. */
            xQueueSendToBack( xQueue1, &count, 0 );
            xSemaphoreGive( xSemaphore1 );
        }
        vTaskDelay(50);
    }
}

void vReceiveQueue(void *pvParameters)
{
    unsigned char localCount;
    while(1)
    {
        /* Receive an item on the created queue.
        Block for portMAX_DELAY ticks if a message is not
        immediately available.*/
        if( xQueueReceive( xQueue1, &localCount, portMAX_DELAY ) )
        {
            writeAllLEDs(localCount);
            SendInteger(localCount);
            SendChar('\r');
            SendChar('\n');
        }
    }
}


int main(void)
{
    initLEDport();
    initSwitchPort();
    initExtInts();
    InitUART(115200, 8, 'N');

    /* Create the semaphore to guard a shared resource. */
    vSemaphoreCreateBinary(xSemaphore1);

    /* Create a queue capable of containing 10 unsigned 
    char values.*/
    xQueue1 = xQueueCreate(10, sizeof(unsigned char));

    xTaskCreate( vDecCountTask, ( signed char * ) "DEC", ...
    configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );	
    xTaskCreate( vIncCountTask, ( signed char * ) "INC", ...
    configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );	
    xTaskCreate( vReceiveQueue, ( signed char * ) "REC", ...
    configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );		
    vTaskStartScheduler();
    while(1)
    {}
}
\end{minted}
